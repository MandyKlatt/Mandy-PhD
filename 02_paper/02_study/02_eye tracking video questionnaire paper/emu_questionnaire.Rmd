---
title: "EMU Questionnaire - Item & Scale Analysis"
output:
  pdf_document: default
  html_notebook: default
---

# Load packages
```{r include=FALSE}
# install.packages("needs")

# suppress "summarize" info. 
# if this line is ommitted, each table using the summarize function will be accompanied with a warning from the console
options(dplyr.summarise.inform = FALSE)

library(needs)
needs(tidyverse,
      lubridate,
      viridis,
      grid,
      gridExtra,
      cowplot,
      readxl,
      ARTofR,
      moments,
      ltm,
      sjPlot,
      kableExtra,
      xtable,
      DescTools,
      formattable,
      psych,
      psy,
      nFactors)

```


# Presence Questionnaire

After each micro-teaching-unit, participants answered items on teaching quality using a validated questionnaire [@helmke2014unterrichtsdiagnostik] and self developed scales on the teacher's presence behavior derived from the research literature. The questionnaire was a 4-point Likert scale (1 = Strongly Disagree; 4 = Strongly Agree).

# Read in data
```{r presence_questionnaire, echo=FALSE, results=TRUE}

# # original scale analysis
# 
# # load data files
# quest.data <- read_excel("./data/data_empschul_labor_lehrperson.xlsx") %>%
#   dplyr::select(LB01_01:LB01_03,
#                 LM01_01,
#                 LM01_03:LM01_08,
#                 LP01_01:LP01_08,
#                 LV01_01:LV01_03) 
# 
# # descriptive data
# describe(quest.data)
# 
# # omega
# omega(quest.data)
# 
# # creating a matrix
# quest.table <- matrix(data = NA, nrow = 4, ncol = 8)
# rownames(quest.table) <- c("LM", "LB", "LP", "LV")
# colnames(quest.table) <- c("N Items","M","SD","Min","Max","Skewness","Kurtosis","Alpha")
# 
# # creating a loop
# i <- "LM"
# 
# for (i in c("LM", "LB", "LP", "LV")) {
# 
# loop.data <- quest.data %>%
#   dplyr::select(starts_with(match = i))
# 
# quest.table[i, "N Items"] <- length(loop.data)
# 
# # calculating mean
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   mean() %>%
#   round(., digits = 2) ->
# quest.table[i, "M"]
# 
# # calculating SD
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   sd() %>%
#   round(., digits = 2) ->
# quest.table[i, "SD"]
# 
# # calculating Min
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   min() %>%
#   round(., digits = 2) ->
# quest.table[i, "Min"]
# 
# # calculating Max
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   max() %>%
#   round(., digits = 2) ->
# quest.table[i, "Max"]
# 
# # calculating Skewness
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   skewness() %>%
#   round(., digits = 2) ->
# quest.table[i, "Skewness"]
# 
# # calculating Kurtosis
# loop.data %>%
#   mutate(mean = rowMeans(.)) %>%
#   pull(mean) %>%
#   kurtosis() %>%
#   round(., digits = 2) ->
# quest.table[i, "Kurtosis"]
# 
# # calculating Alpha
# alpha <- loop.data %>%
#   cronbach.alpha()
# 
# quest.table[i, "Alpha"] <- round(alpha$alpha,2)
# 
# }
# 
# # rename columns
# rownames(quest.table) <- c("Classroom Management", "Balance", "Presence", "Natural Behavior")
# 
# # format and insert table in manuscript
# papaja::apa_table(
# quest.table,
#   caption = "Scale analysis for teachers' self-assessment",
#   # note = "Write Note here",
#   escape = TRUE, # if TRUE special Latex characters are escaped; if this is turned to F captions cannot be rendered. I don't know why...
#   placement = "h", # position of table in page:  exact location (h), at the top (t), bottom (b)
#   font_size = "tiny" # options are tiny, scriptsize, footnotesize, small, normalsize (default), large, Large, LARGE, huge, Huge
# )


# load data files with modified sclaes
quest.data <- read_excel("./data/data_empschul_labor_lehrperson.xlsx") %>%
  dplyr::select(LB01_01:LB01_03,
                LM01_01:LM01_08,
                LP01_01:LP01_08,
                LV01_01:LV01_03) %>% 
  rename(
    LZ01_06 = LM01_06,
    LZ01_07 = LM01_07,
    LZ01_08 = LM01_08
    )
```

# Scale analysis 
```{r presence_questionnaire, echo=FALSE, results=TRUE}
# descriptive data
describe(quest.data)

# creating a matrix
quest.table <- matrix(data = NA, nrow = 5, ncol = 8)
rownames(quest.table) <- c("LM", "LB", "LP", "LV", "LZ")
colnames(quest.table) <- c("N Items","M","SD","Min","Max","Skewness","Kurtosis","Alpha")

# creating a loop
i <- "LM"

for (i in c("LM", "LB", "LP", "LV", "LZ")) {

loop.data <- quest.data %>%
  dplyr::select(starts_with(match = i))

quest.table[i, "N Items"] <- length(loop.data)

# calculating mean
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  mean() %>%
  round(., digits = 2) ->
quest.table[i, "M"]

# calculating SD
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  sd() %>%
  round(., digits = 2) ->
quest.table[i, "SD"]

# calculating Min
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  min() %>%
  round(., digits = 2) ->
quest.table[i, "Min"]

# calculating Max
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  max() %>%
  round(., digits = 2) ->
quest.table[i, "Max"]

# calculating Skewness
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  skewness() %>%
  round(., digits = 2) ->
quest.table[i, "Skewness"]

# calculating Kurtosis
loop.data %>%
  mutate(mean = rowMeans(.)) %>%
  pull(mean) %>%
  kurtosis() %>%
  round(., digits = 2) ->
quest.table[i, "Kurtosis"]

# calculating Alpha
alpha <- loop.data %>%
  cronbach.alpha()

quest.table[i, "Alpha"] <- round(alpha$alpha,2)

# calculating Alpha
omega <- loop.data %>% 
  omega()

}

# rename columns
rownames(quest.table) <- c("Classroom Management", "Balance", "Presence", "Natural Behavior", "Additional")

# format and insert table in manuscript
knitr::kable(
quest.table,
  caption = "Scale analysis for teachers' self-assessment",
  # note = "Write Note here",
  escape = TRUE, # if TRUE special Latex characters are escaped; if this is turned to F captions cannot be rendered. I don't know why...
  placement = "h", # position of table in page:  exact location (h), at the top (t), bottom (b)
  font_size = "tiny" # options are tiny, scriptsize, footnotesize, small, normalsize (default), large, Large, LARGE, huge, Huge
)

```
# Item analysis 
```{r item_analysis_classroom_management, echo=FALSE, results='asis'}
quest.data %>%
  dplyr::select(contains("LM")) %>%
  as.data.frame() %>%
  tab_itemscale(CSS = list(
    css.firsttablerow.col7 = "'cronbachs alpha';"
  ))
```

```{r item_analysis_balance, echo=FALSE, results='asis'}
quest.data %>%
  dplyr::select(contains("LB")) %>%
  as.data.frame() %>%
  tab_itemscale()
```

```{r item_analysis_presence, echo=FALSE, results='asis'}
quest.data %>%
  dplyr::select(contains("LP")) %>%
  as.data.frame() %>%
  tab_itemscale()
```

```{r item_analysis_behavior, echo=FALSE, results='asis'}
quest.data %>%
  dplyr::select(contains("LV")) %>%
  as.data.frame() %>%
  tab_itemscale()
```

```{r item_analysis_additional, echo=FALSE, results='asis'}
quest.data %>%
  dplyr::select(contains("LZ")) %>%
  as.data.frame() %>%
  tab_itemscale()
```

# Exploratory factor analysis
```{r item_analysis_additional, echo=FALSE, results='asis'}

## Bartlett-Test 
# --> prüft, ob Items miteinander korrelieren; das sollten sie tun

cortest.bartlett(quest.data)

# p < .05 --> p signifikant, d.h. Items korrelieren

## Kaiser-Meyer-Olkin-Kriterium (KMO-Werte) Measure of Adequacy (MSA) prüfen 
# gibt an, ob ein Datensatz für eine Faktorenanalyse geeignet ist
# --> KMO & MSA-Werte sollten größer als 0.5 sein

KMO(quest.data)

# overall MSA = 0.7
# einzelne MSA-Werte checken; sollten auch alle größer als 0.5 sein

# Item "LZ01_06 Ich habe vieles mit kurzen Blicken und knappen Gesten geregelt" hat einen Wert von 0.43 --> Ausschluss 

quest.data[, !names(quest.data) %in% c("LZ01_06")] -> clean.data.quest
KMO(clean.data.quest)

## Anzahl Faktoren mit MAP-Test (unter anderem) 
# durch verschiedene Methoden wird optimale Anzahl an Faktoren ermittelt
# MAP-Test wird häufig empfohlen 
# mit Varimax-Rotation (macht Sinn, da man die Interpretierbarkeit der Faktoren verbessert) und ML-Faktorenanalyse

nfactors(clean.data.quest, 
         rotate = "varimax", 
         fm = "mle")

# MAP-Wert = 2 Faktoren

## Anzahl Faktoren kann auch mit Parallelanalyse bestimmt werden

ev <- eigen(cor(clean.data.quest))
ap <- parallel(subject = nrow(clean.data.quest),
               var = ncol(clean.data.quest),
               rep = 100,
               cent = .05)
nS <- nScree(x = ev$values,
             aparallel = ap$eigen$qevpea)
plotnScree(nS)

# Parallel Analysis n = 2 factors

###################################################

## Maximum-Likelihood-Faktorenanalyse
# passt methodisch am besten, wenn man noch eine konfirmatorische Faktorenanalyse machen will
# n Faktoren
# Varimax-Rotation

fit1 <- factanal(x = clean.data.quest,
                 factors = 4, # inhaltlich macht es keinen Sinn, nur 2 Faktoren anzunehmen
                 rotation = "varimax")

# Ergebnisse ausgeben lassen mit 2 Dezimalstellen und Faktorenladung < 0.3 unterdrückt

print(fit1, 
      digits = 2,
      cutoff = .3)

# wir sehen Faktorladungen, um die Faktoren zu interpretieren
# Faktorladungen wurden nur ausgegeben, wenn sie größer als 0.3 und -0.3 waren (um nur große Faktorladungen zu sehen)
# weiter unten: erklärte Varianz (Cumulative Var = 0.29) und wie ist Zuwachs der erklärten Varianz durch einzelne Faktoren
# zurück zu Faktorladungen: ideal wäre eigentlich, wenn jedes Item nur auf einen Faktor lädt

# Mit Uniquenesses kann Kommunalität berechnet werden
# --> zeigen an, wie viel Varianz von den einzelnen Items durch die Faktoren erklärt wird (wie wichtig sind die einzelnen Items für Lösung)

1-fit1$uniquenesses

# Screeplot zur Visualisierung

scree.plot(fit1$correlation)


###################################################

## Hauptachsenfaktorenanalyse
# 4 Faktoren
# Varimax-Rotation

fit2 <- fa(r = clean.data.quest, 
           nfactors = 4, 
           rotate = "varimax")

# Ergebnisse ausgeben

fit2

# Faktorladungen ausgeben

fit2$loadings

# Kommunalitäten ausgeben

fit2$communality

# Sceeplot 

plot(fit2$values, 
     type = "b")

###################################################

## Hauptkomponentenanalyse
# 4 Faktoren
# Varimax-Rotation

fit3 <- principal(r = clean.data.quest,
                  nfactors = 3, 
                  rotate = "varimax")

# Ergebnisse ausgeben

fit3

# Faktorladungen ausgeben

fit3$loadings

# Kommunalitäten ausgeben

fit3$communality

# Sceeplot 

plot(fit3$values, 
     type = "b")

```
