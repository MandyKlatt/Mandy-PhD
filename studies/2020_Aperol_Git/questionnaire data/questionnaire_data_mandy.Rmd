---
title: "Pilot study _Aperol_: questionnaire data"
author: "Mandy Klatt, Gregor Kachel and Anne Deiglmayr"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### HOW TO PREPARE DATA IN EXCEL ###
# use filter to select only lines with an ID in it 
# (i.e. exclude all empty lines or lines with na, ?, x, etc)
# select all columns except the columns for comments
# copy/paste into a new spreadsheet
# click "save as" and choose file type "tab-delimited-text"
####################################

# load tab delimited text file into R; 
# file should be in a subfolder named "data" for the script to select it
raw.data<-read.table("./data/questionnaire_value.txt",sep="\t", header=T) 

view(raw.data)
# loading packages
# if a package is not installed on the current machine, it will install it
if (!require(tidyverse)) install.packages('tidyverse'); library(tidyverse)

# suppress "summarize" info. 
# if this line is committed, each table using the summarize function will be accompanied with a warning from the console
options(dplyr.summarise.inform = FALSE)

# # change data structure: everything is turned into factors except for 
# main.data <- raw.data %>%
#   filter(what == "data"& valid == 1)  %>%
#   mutate(across(!correct&!agem&!aged, as.factor),
#          correct = as.integer(correct))

# print(raw.data)

```


### Plotting questionnaire data


```{r plot classroom management boxplot by groups, echo = FALSE}

### classroom management

# filter by parameter variable, i.e. create a subset for each group (expert/novice/experimenter)
km.data <- raw.data %>% filter(item == "Klassenmanagement",
                               value.1 != "n.a.")

# print(km.data)

# value sometimes contained text before filtering, we have to convert the numbers to numeric
km.data <- km.data %>%  mutate(value = as.numeric(as.character(factor(value.1))))


# create  mean, min, max, sd of classroom management
meankm <- mean(km.data$value.1)
minModul <- min(Modul.data$value)
maxModul <- max(Modul.data$value)
sdModul <- sd(Modul.data$value)
NModul<-length(unique(Modul.data$ID))
# filter by parametervariable, i.e. create a subset for the individual lecturer
ind.Modul.data <- Modul.data %>% filter(Dozierende == params$Dozierende)
# erstelle Mittelwert, min, max, sd for individual lecturer
ind.meanModul <- mean(ind.Modul.data$value)
ind.minModul <- min(ind.Modul.data$value)
ind.maxModul <- max(ind.Modul.data$value)
ind.sdModul <- sd(ind.Modul.data$value)
ind.NModul<-length(unique(ind.Modul.data$ID))
```



test.ind.data <- raw.data %>%
  filter(what == "data" & valid == "1" & trialtype == "test") %>%
  select(id, age, condition, correct)  %>%
  mutate(correct = as.integer(correct),
         age = as.factor(age),
         condition = as.factor(condition),
         groups = paste(age,"-",condition)) %>%
  group_by(groups, age, condition, id) %>%
  summarise(proportion.correct = round(mean(correct)*100, 2))

test.all.data <- raw.data %>%
  filter(what == "data" & valid == "1" & trialtype == "test") %>%
  select(id, age, condition, correct)  %>%
  mutate(correct = as.integer(correct),
         age = as.factor(age),
         condition = as.factor(condition),
         groups = paste(age,"-",condition)) %>%
  group_by(groups, age, condition) %>%
  summarise(proportion.correct = round(mean(correct)*100, 2),
            sd = round(sd(correct)*100,2))

test.raw.data <- raw.data %>%
  filter(what == "data" & valid == "1" & trialtype == "test") %>%
  select(id, age, condition, correct)  %>%
  mutate(correct = as.integer(correct),
         age = as.factor(age),
         condition = as.factor(condition),
         groups = paste(age,"-",condition))

test.boxplot <-ggplot() +
  geom_boxplot(data = test.ind.data, aes(x = groups, y = proportion.correct), )+ # when there is more data add "notch = TRUE" for conf intervalls
  geom_jitter(data = test.ind.data, aes(x = groups, y = proportion.correct, colour=condition), size = 2, width = 0.1) +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 5), limits = c(0,102))+
  labs(x="Groups", y="Proportion Correct")+ # for title add --> title="Proportion of Correct Choices", 
  theme_classic()
   # geom_violin(data = test.raw.data, trim = TRUE , adjust = .7, draw_quantiles = c(0.5), mapping = aes(x=groups, y = correct))
test.boxplot

```

### Performance across trials
Children are tested without feedback. The experimenter merely acknowledges the participant's choice by saying "thank you". The plot below presents the proportion of correct choices across all test trials for both age groups and conditions. 

```{r plot linegraph performance across trials, echo=FALSE}

trial.data <- raw.data %>% 
  filter(what == "data" & valid == "1" & trialtype == "test") %>% 
  mutate(correct = as.integer(correct),
         valid = as.integer(valid),
         trial = as.integer(trial))%>% 
  select(age, condition, trial, correct) %>%
  group_by(age, condition, trial) %>%
    summarise(correct = round(mean(correct)*100, 2))  

trial.plot <- ggplot(trial.data, aes(x = trial, y=correct, colour=condition, linetype=condition))+
  geom_line()+
  geom_point()+
  scale_x_continuous(breaks=trial.data$trial)+
  scale_y_continuous(breaks = scales::pretty_breaks(n = 5), limits = c(0,100))+
  labs(x="Trials", y="Proportion Correct")+ # to add a title --> title="Performance across test trials", 
  theme_classic() +
  facet_grid(age ~ .)
trial.plot

```

### Performance by items
In each trial, children were presented with a target and distractor shape as well as a cue matching the target shape. The counterbalancing ensures that all shapes occur both as target and distractor. Presentation in trials is counterbalanced. The graph below shows children's individual performance aggregated for all target shapes. More incorrect choices for a specific target could indicate that a cue is ambiguous. 

```{r plot performance across items, echo=FALSE, warning=FALSE}

target.ind.data <- raw.data %>%
  filter(what == "data" & valid == "1" & trialtype == "test") %>%
  select(id, age, condition, tar, correct)  %>%
  mutate(correct = as.integer(correct),
         age = as.factor(age),
         condition = as.factor(condition),
         target = as.factor(tar),
         groups = paste(age,"-",condition)) %>%
  group_by(target,age, id) %>%
  summarise(proportion.correct = round(mean(correct)*100, 2))

target.boxplot <-ggplot() +
  geom_boxplot(data = target.ind.data, aes(x = target, y = proportion.correct),outlier.shape = NA)+ # when there is more data add "notch = TRUE" for conf intervalls
  geom_jitter(data = target.ind.data, aes(x = target, y = proportion.correct, colour=target), size = 2, width = 0.3) +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 5), limits = c(0,110))+
  labs(x="Target Shapes", y="Proportion Correct")+ # for title add --> title="Proportion of Correct Choices", 
  theme_classic()+
  facet_grid(age ~ .)
   # geom_violin(data = test.raw.data, trim = TRUE , adjust = .7, draw_quantiles = c(0.5), mapping = aes(x=groups, y = correct))
target.boxplot

```

In addition, the plot below shows individual performance across all distractor shapes. More incorrect choices for a specific distractor might indicate that children prefer to select that distractor over any target.

```{r plot performance across distractor items, echo=FALSE, warning=FALSE}

distractor.ind.data <- raw.data %>%
  filter(what == "data" & valid == "1" & trialtype == "test") %>%
  select(id, age, condition, dis, correct)  %>%
  mutate(correct = as.integer(correct),
         age = as.factor(age),
         condition = as.factor(condition),
         distractor = as.factor(dis),
         groups = paste(age,"-",condition)) %>%
  group_by(distractor,age, id) %>%
  summarise(proportion.correct = round(mean(correct)*100, 2))

distractor.boxplot <-ggplot() +
  geom_boxplot(data = distractor.ind.data, aes(x = distractor, y = proportion.correct),outlier.shape = NA)+ # when there is more data add "notch = TRUE" for conf intervalls
  geom_jitter(data = distractor.ind.data, aes(x = distractor, y = proportion.correct, colour=distractor), size = 2, width = 0.3) +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 5), limits = c(0,110))+
  labs(x="Distractor Shapes", y="Proportion Correct")+ # for title add --> title="Proportion of Correct Choices", 
  theme_classic()+
  facet_grid(age ~ .)
   # geom_violin(data = test.raw.data, trim = TRUE , adjust = .7, draw_quantiles = c(0.5), mapping = aes(x=groups, y = correct))
distractor.boxplot

```


### Testing individual performance against chance
For each individual, we used a binomial test to investigate whether their performance was significantly above chance level (p < 0.05; 50%). The table provides the number and proportion of individuals performing above chance for age experimental group.

```{r table individual performance against chance, echo=FALSE}

ind.binom.data <- raw.data %>%
    filter(what == "data" & valid == "1" & trialtype == "test") %>% 
    select(condition, age, id, correct) %>% 
    mutate(correct = as.integer(correct))%>% 
    group_by(condition, age, id) %>%
    summarise("% correct" = round(mean(correct)*100, 2),
              "sum correct" = sum(correct),
              "sum trials" = length(correct),
              "p" = round(binom.test(sum(correct), length(correct), 
                               p = 0.5, alternative = "greater")$p.value, 3),
              "sig" = if_else(p < 0.05, 1, 0)
              )

sum.binom.data <- ind.binom.data %>%
    group_by(age, condition) %>%
    summarise(N = n_distinct(id),
            "succesfull"  = sum(sig))

sum.binom.data %>%
  mutate("% successful" = (succesfull/N)*100)%>% 
  knitr::kable(digits = 2)

```

### Testing group performance against chance
To test whether each children in both age-group and condition performed above chance on a group level, we used Wilcoxon / Mann-Whitney-U tests. 

xxx To Do xxx

```{r plot performance against chance, echo=FALSE}

# Alternative using one-sample t-tests from emopoint
# this is not working yet as the participants in 4<o comm are all 100% correct
# raw.data %>%
#   filter(what == "data" & valid == "1" & trialtype == "test") %>% 
#   mutate(correct = as.integer(correct)) %>%
#   group_by(condition, age, id) %>%
#   arrange(condition, age) %>%
#   summarise(correct = mean(correct)) %>%
#   summarise(correct = list(correct)) %>%
#   group_by(condition, age) %>%
#   mutate(m = mean(unlist(correct)),
#          sd = sd(unlist(correct)),
#          df= t.test(unlist(correct), mu = 0.5)$parameter,
#          t_value = t.test(unlist(correct), mu = 0.5)$statistic,
#          p = t.test(unlist(correct), mu = 0.5)$p.value,
#          d = cohensD(unlist(correct), mu = 0.5))%>%
#   select(condition,age, m,sd,t_value,p,d) %>% #add df
#   knitr::kable(digits = 2)

```

### Comparing Performance across age-groups and conditions
We used Wilcoxon/Mann-Whitney-U-tests to test for significant differences in children's performance across age-groups and conditions respectively. 

xxx To Do xxx

### Full Analysis (GLMM, ANOVA)
We are going to analyze our outcome (correct choice 0/1) in a 2x2 design (condition (comm, noncomm); age (3yo, 4yo) using either a GLMM or ANOVA depending on prior tests on data structure and model stability. 

xxx To Do xxx

# References

R Core Team (2019). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

Wickham et al., (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686, https://doi.org/10.21105/joss.01686


